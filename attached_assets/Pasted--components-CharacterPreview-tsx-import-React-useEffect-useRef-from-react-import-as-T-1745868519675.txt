// components/CharacterPreview.tsx
import React, { useEffect, useRef } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

interface CharacterPreviewProps {
  character: {
    name: string;
    species: string;
    class: string;
    alignment: string;
    abilities: {
      strength: number;
      dexterity: number;
      constitution: number;
      intelligence: number;
      wisdom: number;
      charisma: number;
    };
    // Other properties as needed
  };
}

const CharacterPreview: React.FC<CharacterPreviewProps> = ({ character }) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
  const characterModelRef = useRef<THREE.Group | null>(null);
  const frameRef = useRef<number | null>(null);
  
  // Initialize and clean up THREE.js scene
  useEffect(() => {
    if (!containerRef.current) return;
    
    // Create scene
    const scene = new THREE.Scene();
    sceneRef.current = scene;
    
    // Add ambient light
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);
    
    // Add directional light
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(0, 1, 2);
    scene.add(directionalLight);
    
    // Create camera
    const camera = new THREE.PerspectiveCamera(
      75,
      containerRef.current.clientWidth / containerRef.current.clientHeight,
      0.1,
      1000
    );
    camera.position.z = 5;
    cameraRef.current = camera;
    
    // Create renderer
    const renderer = new THREE.WebGLRenderer({ 
      antialias: true,
      alpha: true // Enable transparency
    });
    renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
    renderer.setClearColor(0x000000, 0); // Transparent background
    containerRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;
    
    // Add controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.enableZoom = true;
    
    // Add stars to background
    addStarfield(scene);
    
    // Animation loop
    const animate = () => {
      frameRef.current = requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    };
    animate();
    
    // Handle window resizing
    const handleResize = () => {
      if (!containerRef.current || !cameraRef.current || !rendererRef.current) return;
      
      cameraRef.current.aspect = containerRef.current.clientWidth / containerRef.current.clientHeight;
      cameraRef.current.updateProjectionMatrix();
      rendererRef.current.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
    };
    
    window.addEventListener('resize', handleResize);
    
    // Cleanup
    return () => {
      if (frameRef.current) cancelAnimationFrame(frameRef.current);
      window.removeEventListener('resize', handleResize);
      
      if (rendererRef.current && containerRef.current) {
        containerRef.current.removeChild(rendererRef.current.domElement);
      }
      
      renderer.dispose();
    };
  }, []);
  
  // Update character model when character data changes
  useEffect(() => {
    if (!sceneRef.current) return;
    
    // Remove previous character model if exists
    if (characterModelRef.current) {
      sceneRef.current.remove(characterModelRef.current);
    }
    
    // Create character model based on species, class, etc.
    const characterModel = createCharacterModel(character);
    sceneRef.current.add(characterModel);
    characterModelRef.current = characterModel;
    
  }, [character.species, character.class, character.alignment]);
  
  // Function to add starfield to background
  const addStarfield = (scene: THREE.Scene) => {
    const starsGeometry = new THREE.BufferGeometry();
    const starsMaterial = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 0.1,
    });
    
    const starsVertices = [];
    for (let i = 0; i < 1000; i++) {
      const x = (Math.random() - 0.5) * 2000;
      const y = (Math.random() - 0.5) * 2000;
      const z = (Math.random() - 0.5) * 2000;
      starsVertices.push(x, y, z);
    }
    
    starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
    const starField = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(starField);
  };
  
  // Function to create character model based on selected options
  const createCharacterModel = (character: CharacterPreviewProps['character']) => {
    const group = new THREE.Group();
    
    // Base character shape
    const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 32);
    const bodyMaterial = getSpeciesMaterial(character.species);
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    group.add(body);
    
    // Head
    const headGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    const head = new THREE.Mesh(headGeometry, bodyMaterial);
    head.position.y = 1.25;
    group.add(head);
    
    // Add class-specific equipment
    addClassEquipment(group, character.class, character.alignment);
    
    return group;
  };
  
  // Helper function to get material based on species
  const getSpeciesMaterial = (species: string) => {
    switch (species) {
      case 'Human':
        return new THREE.MeshStandardMaterial({ color: 0xffd6c4 });
      case 'Twi\'lek':
        return new THREE.MeshStandardMaterial({ color: 0x4ca9ff });
      case 'Wookiee':
        return new THREE.MeshStandardMaterial({ color: 0x8b4513 });
      case 'Chiss':
        return new THREE.MeshStandardMaterial({ color: 0x0000ff });
      case 'Bothan':
        return new THREE.MeshStandardMaterial({ color: 0x8b8989 });
      case 'Cerean':
        return new THREE.MeshStandardMaterial({ color: 0xddd6c4 });
      default:
        return new THREE.MeshStandardMaterial({ color: 0xcccccc });
    }
  };
  
  // Helper function to add class-specific equipment
  const addClassEquipment = (group: THREE.Group, characterClass: string, alignment: string) => {
    // Add lightsaber for Jedi/Sith
    if (characterClass === 'Jedi Guardian' || characterClass === 'Jedi Consular' || 
        characterClass === 'Sith Warrior' || characterClass === 'Sith Inquisitor') {
      
      // Lightsaber hilt
      const hiltGeometry = new THREE.CylinderGeometry(0.05, 0.07, 0.3, 16);
      const hiltMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
      const hilt = new THREE.Mesh(hiltGeometry, hiltMaterial);
      hilt.position.set(0.6, 0, 0);
      hilt.rotation.z = Math.PI / 2;
      group.add(hilt);
      
      // Lightsaber blade
      const bladeGeometry = new THREE.CylinderGeometry(0.02, 0.02, 1.5, 16);
      
      // Determine color based on alignment
      let bladeColor = 0x0000ff; // Default blue
      if (alignment.includes('Light')) bladeColor = 0x00ff00; // Green
      if (alignment.includes('Dark')) bladeColor = 0xff0000; // Red
      
      const bladeMaterial = new THREE.MeshStandardMaterial({ 
        color: bladeColor,
        emissive: bladeColor,
        emissiveIntensity: 1
      });
      
      const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
      blade.position.set(1.45, 0, 0);
      blade.rotation.z = Math.PI / 2;
      group.add(blade);
    }
    
    // Add blaster for smugglers, bounty hunters
    if (characterClass === 'Smuggler' || characterClass === 'Bounty Hunter') {
      const blasterGeometry = new THREE.BoxGeometry(0.6, 0.2, 0.1);
      const blasterMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
      const blaster = new THREE.Mesh(blasterGeometry, blasterMaterial);
      blaster.position.set(0.6, 0, 0.3);
      group.add(blaster);
    }
    
    // Add tech gear for engineers, scouts
    if (characterClass === 'Engineer' || characterClass === 'Scout') {
      const backpackGeometry = new THREE.BoxGeometry(0.4, 0.6, 0.2);
      const backpackMaterial = new THREE.MeshStandardMaterial({ color: 0x666666 });
      const backpack = new THREE.Mesh(backpackGeometry, backpackMaterial);
      backpack.position.set(0, 0, -0.4);
      group.add(backpack);
    }
  };
  
  return (
    <div className="w-full">
      <h3 className="font-bold mb-2 text-center text-xl">{character.name || 'Character Preview'}</h3>
      <div 
        ref={containerRef} 
        className="w-full h-80 rounded-lg overflow-hidden"
      />
      <div className="mt-3 text-sm">
        <p><span className="font-bold">Species:</span> {character.species || 'Not selected'}</p>
        <p><span className="font-bold">Class:</span> {character.class || 'Not selected'}</p>
        <p><span className="font-bold">Alignment:</span> {character.alignment || 'Not selected'}</p>
      </div>
    </div>
  );
};

export default CharacterPreview;