// Add to client/src/components/Map/SystemMap/Planet.tsx
// or relevant planet component

import React, { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { useTexture } from '@react-three/drei';

interface PlanetProps {
  name: string;
  type: string;
  size: number;
  distance: number;
  selected?: boolean;
  onSelect?: () => void;
  rotationSpeed?: number;
}

// Planet texture mapping (you would need to add these texture files to your project)
const planetTextures = {
  'terrestrial': '/textures/planets/terrestrial.jpg',
  'oceanic': '/textures/planets/oceanic.jpg',
  'desert': '/textures/planets/desert.jpg',
  'ice': '/textures/planets/ice.jpg',
  'volcanic': '/textures/planets/volcanic.jpg',
  'gas-giant': '/textures/planets/gas-giant.jpg',
  'default': '/textures/planets/default.jpg'
};

// Planet atmosphere colors
const atmosphereColors = {
  'terrestrial': '#4a80a3',
  'oceanic': '#4a90f0', 
  'desert': '#d9b77e',
  'ice': '#a0c8f0',
  'volcanic': '#f07848',
  'gas-giant': '#a37bc8',
  'default': '#7a9ab5'
};

export const AdvancedPlanet: React.FC<PlanetProps> = ({ 
  name, 
  type, 
  size, 
  distance, 
  selected = false,
  onSelect = () => {},
  rotationSpeed = 0.001
}) => {
  const planetRef = useRef<THREE.Mesh>(null);
  const atmosphereRef = useRef<THREE.Mesh>(null);
  const cloudsRef = useRef<THREE.Mesh>(null);
  
  // Default texture path with fallback
  const texturePath = planetTextures[type as keyof typeof planetTextures] || planetTextures.default;
  
  // Load textures - you'll need to have these files in your project
  // If you don't have them yet, you can comment out this section and use basic materials instead
  const texture = useTexture(texturePath);
  
  // Generate clouds texture procedurally for planets that need them
  const cloudsTexture = useMemo(() => {
    if (!['terrestrial', 'oceanic', 'gas-giant'].includes(type)) return null;
    
    const size = 512;
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d')!;
    
    // Fill with transparent background
    ctx.fillStyle = 'rgba(0,0,0,0)';
    ctx.fillRect(0, 0, size, size);
    
    // Set cloud style based on planet type
    let cloudColor, cloudCount, cloudSize;
    
    switch (type) {
      case 'terrestrial':
        cloudColor = 'rgba(255, 255, 255, 0.7)';
        cloudCount = 300;
        cloudSize = 4;
        break;
      case 'oceanic':
        cloudColor = 'rgba(255, 255, 255, 0.8)';
        cloudCount = 500;
        cloudSize = 5;
        break;
      case 'gas-giant':
        cloudColor = 'rgba(255, 255, 255, 0.5)';
        cloudCount = 200;
        cloudSize = 8;
        break;
      default:
        cloudColor = 'rgba(255, 255, 255, 0.5)';
        cloudCount = 200;
        cloudSize = 4;
    }
    
    // Draw clouds
    ctx.fillStyle = cloudColor;
    for (let i = 0; i < cloudCount; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = Math.random() * cloudSize + 1;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Create bands for gas giants
    if (type === 'gas-giant') {
      for (let i = 0; i < 10; i++) {
        const y = size * (0.1 + i * 0.08);
        const height = size * 0.03;
        ctx.fillStyle = `rgba(255, 255, 255, ${0.1 + Math.random() * 0.2})`;
        ctx.fillRect(0, y, size, height);
      }
    }
    
    const texture = new THREE.CanvasTexture(canvas);
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    return texture;
  }, [type]);
  
  // Get atmosphere color
  const atmosphereColor = atmosphereColors[type as keyof typeof atmosphereColors] || atmosphereColors.default;
  
  // Planet rotation animation
  useFrame(() => {
    if (planetRef.current) {
      planetRef.current.rotation.y += rotationSpeed;
    }
    
    if (cloudsRef.current) {
      // Clouds rotate slightly faster than the planet
      cloudsRef.current.rotation.y += rotationSpeed * 1.2;
    }
  });
  
  // Selection animation
  useFrame(() => {
    if (atmosphereRef.current) {
      const material = atmosphereRef.current.material as THREE.ShaderMaterial;
      const pulseFrequency = selected ? 2.0 : 0.5;
      const time = performance.now() / 1000;
      
      // Pulse the atmosphere when selected
      material.uniforms.glowIntensity.value = 0.5 + (selected ? 0.3 * Math.sin(time * pulseFrequency) : 0);
    }
  });
  
  // Atmosphere shader
  const atmosphereMaterial = useMemo(() => {
    const color = new THREE.Color(atmosphereColor);
    
    return new THREE.ShaderMaterial({
      uniforms: {
        glowColor: { value: color },
        glowIntensity: { value: 0.5 },
        planetRadius: { value: size }
      },
      vertexShader: `
        varying vec3 vNormal;
        varying vec3 vPosition;
        
        void main() {
          vNormal = normalize(normalMatrix * normal);
          vPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        varying vec3 vNormal;
        varying vec3 vPosition;
        
        uniform vec3 glowColor;
        uniform float glowIntensity;
        uniform float planetRadius;
        
        void main() {
          // Calculate rim lighting effect
          float intensity = pow(1.0 - dot(normalize(-vPosition), normalize(vNormal)), 2.0);
          
          // Adjust glow falloff
          intensity = pow(intensity, 1.5) * glowIntensity;
          
          gl_FragColor = vec4(glowColor, intensity);
        }
      `,
      side: THREE.BackSide,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
  }, [atmosphereColor, size]);
  
  return (
    <group position={[distance, 0, 0]} onClick={onSelect}>
      {/* Planet */}
      <mesh ref={planetRef}>
        <sphereGeometry args={[size, 32, 32]} />
        <meshStandardMaterial 
          map={texture} 
          roughness={0.8} 
          metalness={0.1} 
        />
      </mesh>
      
      {/* Clouds layer */}
      {cloudsTexture && (
        <mesh ref={cloudsRef}>
          <sphereGeometry args={[size * 1.02, 32, 32]} />
          <meshStandardMaterial 
            map={cloudsTexture} 
            transparent={true} 
            opacity={0.7}
            side={THREE.DoubleSide}
          />
        </mesh>
      )}

      {/* Atmosphere glow */}
      <mesh ref={atmosphereRef}>
        <sphereGeometry args={[size * 1.2, 32, 32]} />
        <primitive object={atmosphereMaterial} attach="material" />
      </mesh>
      
      {/* Selection indicator */}
      {selected && (
        <mesh>
          <ringGeometry args={[size * 1.4, size * 1.45, 64]} />
          <meshBasicMaterial color="#ffffff" transparent={true} opacity={0.3} side={THREE.DoubleSide} />
        </mesh>
      )}
      
      {/* Planet name label */}
      <group position={[0, size * 1.8, 0]}>
        <sprite scale={[5, 1, 1]}>
          <spriteMaterial transparent={true} opacity={0.8}>
            <canvasTexture 
              attach="map" 
              image={(() => {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const ctx = canvas.getContext('2d')!;
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = 'white';
                ctx.fillText(name, canvas.width / 2, canvas.height / 2);
                return canvas;
              })()}
            />
          </spriteMaterial>
        </sprite>
      </group>
    </group>
  );
};