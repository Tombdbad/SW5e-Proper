// store/useCharacterStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { Character, emptyCharacter } from '../shared/schema/character';

interface CharacterState {
  // Character data
  character: Character;
  
  // Character creation flow state
  currentStep: number;
  completedSteps: Record<number, boolean>;
  isDirty: boolean;
  isSaving: boolean;
  
  // Actions
  setCharacter: (character: Character) => void;
  updateCharacter: <K extends keyof Character>(key: K, value: Character[K]) => void;
  updateNestedCharacter: (path: string[], value: any) => void;
  resetCharacter: () => void;
  
  // Creation flow actions
  setCurrentStep: (step: number) => void;
  markStepComplete: (step: number, isComplete: boolean) => void;
  
  // Persistence actions
  saveCharacter: () => Promise<void>;
  loadCharacter: (id: string) => Promise<void>;
}

export const useCharacterStore = create<CharacterState>()(
  persist(
    (set, get) => ({
      // Initial state
      character: emptyCharacter,
      currentStep: 0,
      completedSteps: {},
      isDirty: false,
      isSaving: false,
      
      // Basic character update actions
      setCharacter: (character) => set({ 
        character,
        isDirty: true
      }),
      
      updateCharacter: (key, value) => set((state) => ({
        character: { ...state.character, [key]: value },
        isDirty: true
      })),
      
      updateNestedCharacter: (path, value) => set((state) => {
        // Create a deep copy of the character
        const updatedCharacter = JSON.parse(JSON.stringify(state.character));
        
        // Navigate to the nested property
        let current = updatedCharacter;
        for (let i = 0; i < path.length - 1; i++) {
          current = current[path[i]];
        }
        
        // Update the value
        current[path[path.length - 1]] = value;
        
        return {
          character: updatedCharacter,
          isDirty: true
        };
      }),
      
      resetCharacter: () => set({
        character: emptyCharacter,
        currentStep: 0,
        completedSteps: {},
        isDirty: false
      }),
      
      // Creation flow state management
      setCurrentStep: (step) => set({ currentStep: step }),
      
      markStepComplete: (step, isComplete) => set((state) => ({
        completedSteps: { ...state.completedSteps, [step]: isComplete }
      })),
      
      // Persistence methods (to be implemented with API integration)
      saveCharacter: async () => {
        const { character } = get();
        set({ isSaving: true });
        
        try {
          // API call would go here
          // const response = await api.saveCharacter(character);
          
          // For now, just simulate an API call
          await new Promise(resolve => setTimeout(resolve, 500));
          
          set({ 
            isDirty: false,
            isSaving: false
          });
          
          return Promise.resolve();
        } catch (error) {
          set({ isSaving: false });
          return Promise.reject(error);
        }
      },
      
      loadCharacter: async (id) => {
        set({ isSaving: true });
        
        try {
          // API call would go here
          // const loadedCharacter = await api.getCharacter(id);
          
          // For now, just simulate an API call
          await new Promise(resolve => setTimeout(resolve, 500));
          const loadedCharacter = { ...emptyCharacter, id };
          
          set({ 
            character: loadedCharacter,
            isDirty: false,
            isSaving: false
          });
          
          return Promise.resolve();
        } catch (error) {
          set({ isSaving: false });
          return Promise.reject(error);
        }
      }
    }),
    {
      name: 'sw5e-character-storage',
      // Only persist the character data, not the UI state
      partialize: (state) => ({ character: state.character }),
    }
  )
);