# Prompt for SW5E Character Creator: Comprehensive State Management Solution

## Project Context
I'm developing a Star Wars 5th Edition (SW5E) character creator application built with:
- React + TypeScript + Vite frontend
- Zustand for state management (current stores in `client/src/lib/stores/`)
- React Query for server state
- Feature-based organization with domain-specific stores
- Zod for validation

## Current Implementation
We currently have:
- Basic Zustand stores organized by domain:
  - `useCharacter.ts` - Character state management
  - `useCampaign.ts` - Campaign state management
  - `useCombat.ts` - Combat system state
- Simple state persistence with localStorage
- Limited integration between React Query and Zustand
- Basic form state with React Hook Form

## Request
Please enhance our state management with:

1. **Comprehensive Character State**:
   - Create an enhanced character store with:
     - Normalized state structure for complex nested data
     - Derived state calculations (ability modifiers, proficiency bonus, etc.)
     - Character history tracking for undo/redo capability
     - Middleware for state validation using Zod
     - Optimistic updates with React Query integration

2. **Robust Persistence Layer**:
   - Implement:
     - Efficient persistence strategy (localStorage + IndexedDB)
     - State hydration on application load
     - Sync conflict resolution for multi-tab usage
     - Character version management
     - Export/import functionality with JSON schema validation

3. **Form State Integration**:
   - Create:
     - Two-way binding between Zustand and React Hook Form
     - Field-level validation that integrates with SW5E rules
     - Multi-step form state management for character creation
     - Conditional field visibility based on character choices

4. **Performance Optimizations**:
   - Implement:
     - Selective state updates to prevent unnecessary renders
     - Memoization strategies for expensive calculations
     - Component-level state separation where appropriate
     - Debug tools and performance monitoring

## Technical Requirements

### Zustand Store Structure
Follow our existing pattern but enhance it:
```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';
import { devtools } from 'zustand/middleware';
import { CharacterSchema } from '../schemas/character';

export interface CharacterState {
  // Base state
  characters: Record<string, Character>;
  activeCharacterId: string | null;
  
  // Derived state (calculated)
  derived: {
    activeCharacter: Character | null;
    abilityModifiers: Record<string, number>;
    proficiencyBonus: number;
    savingThrows: Record<string, number>;
    skillModifiers: Record<string, number>;
    // Additional derived values...
  };
  
  // Actions
  actions: {
    createCharacter: (characterData: CharacterInput) => void;
    updateCharacter: (id: string, updates: Partial<Character>) => void;
    deleteCharacter: (id: string) => void;
    setActiveCharacter: (id: string) => void;
    updateAbilityScore: (ability: string, value: number) => void;
    addClassLevel: (classId: string) => void;
    // Additional actions...
  };
  
  // History tracking
  history: {
    past: CharacterState['characters'][];
    future: CharacterState['characters'][];
    undo: () => void;
    redo: () => void;
    canUndo: boolean;
    canRedo: boolean;
  };
}
```

### Integration with React Query
```typescript
// Example of integrating React Query mutations with Zustand
export const useCreateCharacter = () => {
  const { addCharacter } = useCharacterStore((state) => state.actions);
  
  return useMutation({
    mutationFn: (character: CharacterInput) => 
      axios.post('/api/sw5e/character', character),
    onSuccess: (data) => {
      addCharacter(data.character);
      queryClient.invalidateQueries(['characters']);
    },
  });
};
```

### Persistence Configuration
```typescript
// Enhanced persistence with custom storage
const characterStore = create<CharacterState>()(
  devtools(
    persist(
      immer((set, get) => ({
        // State and actions...
      })),
      {
        name: 'sw5e-character-storage',
        storage: createCustomStorage(),
        partialize: (state) => ({
          characters: state.characters,
          activeCharacterId: state.activeCharacterId,
          // Exclude derived state, which can be recalculated
        }),
        onRehydrateStorage: (state) => {
          return (rehydratedState, error) => {
            if (error) {
              console.error('Error rehydrating character state:', error);
            } else if (rehydratedState) {
              // Recalculate derived state after rehydration
              set(produce(rehydratedState, (draft) => {
                recalculateDerivedState(draft);
              }));
            }
          };
        },
      }
    )
  )
);
```

### Derived State Calculation
```typescript
// Example of derived state calculation
const recalculateDerivedState = (state: CharacterState) => {
  const activeCharacter = state.activeCharacterId 
    ? state.characters[state.activeCharacterId] 
    : null;
    
  if (!activeCharacter) {
    state.derived = initialDerivedState;
    return;
  }
  
  // Calculate ability modifiers
  const abilityModifiers = Object.entries(activeCharacter.abilityScores)
    .reduce((acc, [ability, score]) => {
      acc[ability] = Math.floor((score - 10) / 2);
      return acc;
    }, {} as Record<string, number>);
  
  // Calculate proficiency bonus
  const characterLevel = activeCharacter.classes
    .reduce((total, cls) => total + cls.level, 0);
  const proficiencyBonus = Math.ceil(1 + (characterLevel / 4));
  
  // Update derived state
  state.derived = {
    activeCharacter,
    abilityModifiers,
    proficiencyBonus,
    // Calculate other derived values...
  };
};
```

### Form Integration
```typescript
// Example React Hook Form integration with Zustand
export const useCharacterForm = (characterId?: string) => {
  const character = useCharacterStore(
    (state) => characterId ? state.characters[characterId] : null
  );
  const { updateCharacter } = useCharacterStore((state) => state.actions);
  
  const methods = useForm<CharacterFormData>({
    resolver: zodResolver(CharacterFormSchema),
    defaultValues: character ? mapCharacterToForm(character) : defaultFormValues,
  });
  
  // Connect form to store
  const onSubmit = (data: CharacterFormData) => {
    if (characterId) {
      updateCharacter(characterId, mapFormToCharacter(data));
    } else {
      // Create new character flow
    }
  };
  
  return {
    ...methods,
    onSubmit: methods.handleSubmit(onSubmit),
  };
};
```

## Deliverables
1. Enhanced character store in `client/src/lib/stores/useCharacter.ts`
2. Custom persistence implementation in `client/src/lib/stores/persistence.ts`
3. Form state integration hooks in `client/src/hooks/useCharacterForm.ts`
4. Store selectors for performance in `client/src/lib/stores/selectors.ts`
5. Debug middleware in `client/src/lib/stores/middleware.ts`

Ensure all code is well-typed with TypeScript and includes documentation. The implementation should be optimized for performance while maintaining the complex state requirements of the SW5E character system.