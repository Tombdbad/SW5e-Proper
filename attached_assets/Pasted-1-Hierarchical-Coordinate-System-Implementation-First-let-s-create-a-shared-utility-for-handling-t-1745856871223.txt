1. Hierarchical Coordinate System Implementation
First, let's create a shared utility for handling the hierarchical coordinates:
typescript// shared/coordinates.ts
export type CoordinateLevel = 'galactic' | 'system' | 'planet' | 'region' | 'local';

export interface Coordinates {
  galactic?: string;
  system?: string;
  planet?: string;
  region?: string;
  local?: string;
  grid?: string;
}

export function parseCoordinateString(coordString: string): Coordinates {
  const parts = coordString.split(' - ');
  const coords: Coordinates = {};
  
  if (parts.length > 0) coords.galactic = parts[0];
  if (parts.length > 1) coords.system = parts[1];
  if (parts.length > 2) coords.planet = parts[2];
  if (parts.length > 3) coords.region = parts[3];
  
  // Handle grid coordinates if present in the last part
  if (parts.length > 4) {
    const lastPart = parts[4];
    const gridMatch = lastPart.match(/\(Grid: ([A-Z0-9]+)\)/);
    
    if (gridMatch) {
      coords.local = lastPart.split(' (Grid')[0];
      coords.grid = gridMatch[1];
    } else {
      coords.local = lastPart;
    }
  }
  
  return coords;
}

export function formatCoordinateString(coords: Coordinates): string {
  let result = coords.galactic || '';
  
  if (coords.system) result += ` - ${coords.system}`;
  if (coords.planet) result += ` - ${coords.planet}`;
  if (coords.region) result += ` - ${coords.region}`;
  
  if (coords.local) {
    result += ` - ${coords.local}`;
    if (coords.grid) result += ` (Grid: ${coords.grid})`;
  }
  
  return result;
}
2. Update Database Schema
Let's enhance the database schema to support Star Wars-specific entities:
typescript// shared/schema.ts
import { relations } from "drizzle-orm";
import { 
  pgTable, text, timestamp, serial, integer, 
  boolean, jsonb, uuid 
} from "drizzle-orm/pg-core";

// Existing tables...

export const locations = pgTable('locations', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  description: text('description'),
  coordinateString: text('coordinate_string').notNull(),
  coordinateData: jsonb('coordinate_data').$type<Coordinates>(),
  campaignId: integer('campaign_id').references(() => campaigns.id, { onDelete: 'cascade' }),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

export const npcs = pgTable('npcs', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  species: text('species'),
  description: text('description'),
  locationId: integer('location_id').references(() => locations.id),
  campaignId: integer('campaign_id').references(() => campaigns.id, { onDelete: 'cascade' }),
  metadata: jsonb('metadata'),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

export const items = pgTable('items', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  description: text('description'),
  type: text('type'), // weapon, tool, artifact, etc.
  ownerId: integer('owner_id').references(() => characters.id),
  locationId: integer('location_id').references(() => locations.id),
  campaignId: integer('campaign_id').references(() => campaigns.id, { onDelete: 'cascade' }),
  metadata: jsonb('metadata'),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

// Add Star Wars specific fields to the characters table
export const characterStarWarsData = pgTable('character_star_wars_data', {
  id: serial('id').primaryKey(),
  characterId: integer('character_id').references(() => characters.id, { onDelete: 'cascade' }),
  species: text('species'),
  homeworld: text('homeworld'),
  affiliation: text('affiliation'), // Rebellion, Empire, etc.
  forceUser: boolean('force_user').default(false),
  forcePowers: jsonb('force_powers').$type<string[]>(),
  customData: jsonb('custom_data'),
});

// Relations
export const characterRelations = relations(characters, ({ one, many }) => ({
  user: one(users, {
    fields: [characters.userId],
    references: [users.id],
  }),
  campaign: one(campaigns, {
    fields: [characters.campaignId],
    references: [campaigns.id],
  }),
  starWarsData: one(characterStarWarsData, {
    fields: [characters.id],
    references: [characterStarWarsData.characterId],
  }),
  items: many(items, { relationName: "characterItems" }),
}));

export const locationRelations = relations(locations, ({ one, many }) => ({
  campaign: one(campaigns, {
    fields: [locations.campaignId],
    references: [campaigns.id],
  }),
  npcs: many(npcs),
  items: many(items),
}));

export const campaignRelations = relations(campaigns, ({ many }) => ({
  characters: many(characters),
  locations: many(locations),
  npcs: many(npcs),
  items: many(items),
}));
3. API Routes for Star Wars Content
Add routes to handle Star Wars-specific data:
typescript// server/routes.ts
import express from "express";
import { db } from "./db";
import { campaigns, characters, locations, npcs, items, characterStarWarsData } from "../shared/schema";
import { eq } from "drizzle-orm";
import { parseCoordinateString, formatCoordinateString } from "../shared/coordinates";

const router = express.Router();

// Existing routes...

// Location routes
router.get("/api/campaigns/:campaignId/locations", async (req, res) => {
  const campaignId = parseInt(req.params.campaignId);
  try {
    const campaignLocations = await db.query.locations.findMany({
      where: eq(locations.campaignId, campaignId),
      with: {
        npcs: true,
        items: true,
      },
    });
    res.json(campaignLocations);
  } catch (error) {
    console.error("Error fetching locations:", error);
    res.status(500).json({ error: "Failed to fetch locations" });
  }
});

router.post("/api/campaigns/:campaignId/locations", async (req, res) => {
  const campaignId = parseInt(req.params.campaignId);
  const { name, description, coordinateString } = req.body;
  
  try {
    const coordData = parseCoordinateString(coordinateString);
    
    const newLocation = await db.insert(locations).values({
      name,
      description,
      coordinateString,
      coordinateData: coordData,
      campaignId,
    }).returning();
    
    res.status(201).json(newLocation[0]);
  } catch (error) {
    console.error("Error creating location:", error);
    res.status(500).json({ error: "Failed to create location" });
  }
});

// NPC routes
router.get("/api/campaigns/:campaignId/npcs", async (req, res) => {
  const campaignId = parseInt(req.params.campaignId);
  try {
    const campaignNpcs = await db.query.npcs.findMany({
      where: eq(npcs.campaignId, campaignId),
    });
    res.json(campaignNpcs);
  } catch (error) {
    console.error("Error fetching NPCs:", error);
    res.status(500).json({ error: "Failed to fetch NPCs" });
  }
});

router.post("/api/campaigns/:campaignId/npcs", async (req, res) => {
  const campaignId = parseInt(req.params.campaignId);
  const { name, species, description, locationId, metadata } = req.body;
  
  try {
    const newNpc = await db.insert(npcs).values({
      name,
      species,
      description,
      locationId,
      campaignId,
      metadata,
    }).returning();
    
    res.status(201).json(newNpc[0]);
  } catch (error) {
    console.error("Error creating NPC:", error);
    res.status(500).json({ error: "Failed to create NPC" });
  }
});

// Star Wars character data routes
router.get("/api/characters/:characterId/starwars", async (req, res) => {
  const characterId = parseInt(req.params.characterId);
  try {
    const data = await db.query.characterStarWarsData.findFirst({
      where: eq(characterStarWarsData.characterId, characterId),
    });
    res.json(data || {});
  } catch (error) {
    console.error("Error fetching Star Wars character data:", error);
    res.status(500).json({ error: "Failed to fetch Star Wars character data" });
  }
});

router.post("/api/characters/:characterId/starwars", async (req, res) => {
  const characterId = parseInt(req.params.characterId);
  const { species, homeworld, affiliation, forceUser, forcePowers, customData } = req.body;
  
  try {
    // Check if data already exists
    const existing = await db.query.characterStarWarsData.findFirst({
      where: eq(characterStarWarsData.characterId, characterId),
    });
    
    if (existing) {
      // Update existing record
      const updated = await db.update(characterStarWarsData)
        .set({ species, homeworld, affiliation, forceUser, forcePowers, customData })
        .where(eq(characterStarWarsData.characterId, characterId))
        .returning();
      res.json(updated[0]);
    } else {
      // Create new record
      const created = await db.insert(characterStarWarsData).values({
        characterId,
        species,
        homeworld,
        affiliation,
        forceUser,
        forcePowers,
        customData,
      }).returning();
      res.status(201).json(created[0]);
    }
  } catch (error) {
    console.error("Error saving Star Wars character data:", error);
    res.status(500).json({ error: "Failed to save Star Wars character data" });
  }
});

export default router;
4. Client-Side Components for Star Wars UI
Let's create some Star Wars-themed components:
typescript// client/src/components/GalacticMap.tsx
import React, { useEffect, useState } from 'react';
import { Coordinates } from '../../../shared/coordinates';

interface GalacticMapProps {
  locations: Array<{
    id: number;
    name: string;
    coordinateString: string;
    coordinateData: Coordinates;
  }>;
  currentLocation?: number;
  onLocationSelect: (locationId: number) => void;
}

const GalacticMap: React.FC<GalacticMapProps> = ({ 
  locations, 
  currentLocation,
  onLocationSelect 
}) => {
  const [zoomLevel, setZoomLevel] = useState<'galactic' | 'system' | 'planet' | 'local'>('galactic');
  const [filter, setFilter] = useState<Partial<Coordinates>>({});
  
  // Filter locations based on current zoom level and filters
  const filteredLocations = locations.filter(loc => {
    const coords = loc.coordinateData;
    
    // Match all non-undefined filters
    return Object.entries(filter).every(([key, value]) => {
      return value === undefined || coords[key as keyof Coordinates] === value;
    });
  });
  
  // Group locations by the current zoom level + 1
  const groupedLocations = filteredLocations.reduce((acc, loc) => {
    const coords = loc.coordinateData;
    let groupKey = '';
    
    switch (zoomLevel) {
      case 'galactic':
        groupKey = coords.system || 'Unknown System';
        break;
      case 'system':
        groupKey = coords.planet || 'Unknown Planet';
        break;
      case 'planet':
        groupKey = coords.region || 'Unknown Region';
        break;
      case 'local':
        groupKey = coords.local || 'Unknown Area';
        break;
    }
    
    if (!acc[groupKey]) acc[groupKey] = [];
    acc[groupKey].push(loc);
    return acc;
  }, {} as Record<string, typeof filteredLocations>);
  
  const handleZoomIn = (groupKey: string) => {
    let newFilter: Partial<Coordinates> = { ...filter };
    
    switch (zoomLevel) {
      case 'galactic':
        newFilter.system = groupKey;
        setZoomLevel('system');
        break;
      case 'system':
        newFilter.planet = groupKey;
        setZoomLevel('planet');
        break;
      case 'planet':
        newFilter.region = groupKey;
        setZoomLevel('local');
        break;
    }
    
    setFilter(newFilter);
  };
  
  const handleZoomOut = () => {
    let newFilter: Partial<Coordinates> = { ...filter };
    
    switch (zoomLevel) {
      case 'system':
        delete newFilter.system;
        setZoomLevel('galactic');
        break;
      case 'planet':
        delete newFilter.planet;
        setZoomLevel('system');
        break;
      case 'local':
        delete newFilter.region;
        setZoomLevel('planet');
        break;
    }
    
    setFilter(newFilter);
  };
  
  return (
    <div className="galactic-map">
      <div className="galactic-map-header">
        <h3>Galactic Map - {zoomLevel} View</h3>
        {zoomLevel !== 'galactic' && (
          <button onClick={handleZoomOut} className="btn-zoom-out">
            Zoom Out
          </button>
        )}
      </div>
      
      <div className="galactic-map-content">
        {Object.entries(groupedLocations).map(([groupKey, locs]) => (
          <div key={groupKey} className="map-group">
            <h4>{groupKey}</h4>
            {zoomLevel !== 'local' ? (
              <button onClick={() => handleZoomIn(groupKey)} className="btn-zoom-in">
                Explore {groupKey}
              </button>
            ) : (
              <div className="local-grid">
                {locs.map(loc => (
                  <div 
                    key={loc.id}
                    className={`grid-location ${loc.id === currentLocation ? 'current' : ''}`}
                    onClick={() => onLocationSelect(loc.id)}
                  >
                    <span>{loc.name}</span>
                    {loc.coordinateData.grid && (
                      <span className="grid-coord">{loc.coordinateData.grid}</span>
                    )}
                  </div>
                ))}
              </div>
            )}
          </div>
        ))}
      </div>
    </div>
  );
};

export default GalacticMap;
typescript// client/src/components/StarWarsCharacterSheet.tsx
import React, { useState, useEffect } from 'react';
import axios from 'axios';

interface StarWarsCharacterData {
  species: string;
  homeworld: string;
  affiliation: string;
  forceUser: boolean;
  forcePowers: string[];
  customData: Record<string, any>;
}

interface CharacterSheetProps {
  characterId: number;
}

const StarWarsCharacterSheet: React.FC<CharacterSheetProps> = ({ characterId }) => {
  const [loading, setLoading] = useState(true);
  const [data, setData] = useState<StarWarsCharacterData>({
    species: '',
    homeworld: '',
    affiliation: '',
    forceUser: false,
    forcePowers: [],
    customData: {}
  });
  const [editMode, setEditMode] = useState(false);
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await axios.get(`/api/characters/${characterId}/starwars`);
        if (response.data) {
          setData(response.data);
        }
        setLoading(false);
      } catch (error) {
        console.error("Error fetching Star Wars character data:", error);
        setLoading(false);
      }
    };
    
    fetchData();
  }, [characterId]);
  
  const handleChange = (field: keyof StarWarsCharacterData, value: any) => {
    setData(prev => ({ ...prev, [field]: value }));
  };
  
  const handleForcePowerChange = (index: number, value: string) => {
    const newPowers = [...data.forcePowers];
    newPowers[index] = value;
    handleChange('forcePowers', newPowers);
  };
  
  const addForcePower = () => {
    handleChange('forcePowers', [...data.forcePowers, '']);
  };
  
  const removeForcePower = (index: number) => {
    const newPowers = data.forcePowers.filter((_, i) => i !== index);
    handleChange('forcePowers', newPowers);
  };
  
  const saveChanges = async () => {
    try {
      await axios.post(`/api/characters/${characterId}/starwars`, data);
      setEditMode(false);
    } catch (error) {
      console.error("Error saving Star Wars character data:", error);
    }
  };
  
  if (loading) {
    return <div>Loading character data...</div>;
  }
  
  return (
    <div className="star-wars-character-sheet">
      <div className="sheet-header">
        <h3>Star Wars Character Details</h3>
        {!editMode ? (
          <button onClick={() => setEditMode(true)} className="btn-edit">Edit</button>
        ) : (
          <div className="edit-actions">
            <button onClick={saveChanges} className="btn-save">Save</button>
            <button onClick={() => setEditMode(false)} className="btn-cancel">Cancel</button>
          </div>
        )}
      </div>
      
      <div className="sheet-content">
        <div className="field-group">
          <label>Species</label>
          {editMode ? (
            <input 
              type="text" 
              value={data.species} 
              onChange={(e) => handleChange('species', e.target.value)} 
            />
          ) : (
            <span>{data.species || 'Unknown'}</span>
          )}
        </div>
        
        <div className="field-group">
          <label>Homeworld</label>
          {editMode ? (
            <input 
              type="text" 
              value={data.homeworld} 
              onChange={(e) => handleChange('homeworld', e.target.value)} 
            />
          ) : (
            <span>{data.homeworld || 'Unknown'}</span>
          )}
        </div>
        
        <div className="field-group">
          <label>Affiliation</label>
          {editMode ? (
            <input 
              type="text" 
              value={data.affiliation} 
              onChange={(e) => handleChange('affiliation', e.target.value)} 
            />
          ) : (
            <span>{data.affiliation || 'None'}</span>
          )}
        </div>
        
        <div className="field-group">
          <label>Force User</label>
          {editMode ? (
            <input 
              type="checkbox" 
              checked={data.forceUser} 
              onChange={(e) => handleChange('forceUser', e.target.checked)} 
            />
          ) : (
            <span>{data.forceUser ? 'Yes' : 'No'}</span>
          )}
        </div>
        
        {(data.forceUser || (editMode && data.forcePowers.length > 0)) && (
          <div className="field-group">
            <label>Force Powers</label>
            {editMode ? (
              <div className="force-powers-edit">
                {data.forcePowers.map((power, index) => (
                  <div key={index} className="power-input">
                    <input 
                      type="text" 
                      value={power} 
                      onChange={(e) => handleForcePowerChange(index, e.target.value)} 
                    />
                    <button onClick={() => removeForcePower(index)} className="btn-remove">
                      Remove
                    </button>
                  </div>
                ))}
                <button onClick={addForcePower} className="btn-add-power">
                  Add Force Power
                </button>
              </div>
            ) : (
              <ul className="force-powers-list">
                {data.forcePowers.length > 0 ? (
                  data.forcePowers.map((power, index) => (
                    <li key={index}>{power}</li>
                  ))
                ) : (
                  <li>No force powers</li>
                )}
              </ul>
            )}
          </div>
        )}
      </div>
    </div>
  );
};

export default StarWarsCharacterSheet;
5. Creating the Campaign Debrief Context Processor
This component will handle the JSON processing for campaign debriefs:
typescript// client/src/components/CampaignDebrief.tsx
import React, { useState, useEffect } from 'react';
import axios from 'axios';

interface DebriefsProps {
  campaignId: number;
  characterId: number;
}

interface ReportData {
  character: {
    name: string;
    class: string;
    level: number;
    attributes: Record<string, number>;
    bonds: string[];
    alignment: string;
    backstory_keywords: string[];
  };
  campaign: {
    current_objective: string;
    related_npcs: string[];
    related_locations: string[];
    related_items: string[];
  };
}

const CampaignDebrief: React.FC<DebriefsProps> = ({ campaignId, characterId }) => {
  const [loading, setLoading] = useState(true);
  const [reportData, setReportData] = useState<ReportData | null>(null);
  const [userInput, setUserInput] = useState('');
  const [aiResponse, setAiResponse] = useState('');
  const [processingRequest, setProcessingRequest] = useState(false);
  
  useEffect(() => {
    const fetchDebriefData = async () => {
      try {
        // Fetch character data
        const charResponse = await axios.get(`/api/characters/${characterId}`);
        const character = charResponse.data;
        
        // Fetch campaign data
        const campaignResponse = await axios.get(`/api/campaigns/${campaignId}`);
        const campaign = campaignResponse.data;
        
        // Fetch locations
        const locationsResponse = await axios.get(`/api/campaigns/${campaignId}/locations`);
        const locations = locationsResponse.data;
        
        // Fetch NPCs
        const npcsResponse = await axios.get(`/api/campaigns/${campaignId}/npcs`);
        const npcs = npcsResponse.data;
        
        // Fetch Star Wars data
        const swDataResponse = await axios.get(`/api/characters/${characterId}/starwars`);
        const swData = swDataResponse.data || {};
        
        // Construct the report data
        const report: ReportData = {
          character: {
            name: character.name,
            class: character.class || 'Unknown',
            level: character.level || 1,
            attributes: character.attributes || {
              strength: 10,
              dexterity: 10, 
              constitution: 10,
              intelligence: 10,
              wisdom: 10,
              charisma: 10
            },
            bonds: character.bonds || [],
            alignment: character.alignment || 'Neutral',
            backstory_keywords: character.backstory_keywords || []
          },
          campaign: {
            current_objective: campaign.current_objective || 'No current objective',
            related_npcs: npcs.map((npc: any) => npc.name),
            related_locations: locations.map((loc: any) => loc.name),
            related_items: character.items?.map((item: any) => item.name) || []
          }
        };
        
        setReportData(report);
        setLoading(false);
      } catch (error) {
        console.error("Error fetching debrief data:", error);
        setLoading(false);
      }
    };
    
    fetchDebriefData();
  }, [campaignId, characterId]);
  
  const handleSubmit = async () => {
    if (!reportData) return;
    
    setProcessingRequest(true);
    
    try {
      // Construct the AI request payload
      const payload = {
        report: reportData,
        instructions: {
          decode: "Interpret the 'report' section to understand the character's current state and campaign objectives.",
          encode: "Generate a 'diff' in this .json structure to represent any changes in the game state.",
          format: "Describe the unfolding events to the player in a narrative style."
        },
        userInput: userInput
      };
      
      // Call your AI endpoint
      const response = await axios.post('/api/ai/process-debrief', payload);
      setAiResponse(response.data.description || response.data);
      
      // If the AI returned updates, apply them
      if (response.data.diff) {
        // TODO: Handle updating the game state based on AI response
        console.log("AI suggested updates:", response.data.diff);
      }
      
    } catch (error) {
      console.error("Error processing AI debrief:", error);
      setAiResponse("Failed to process your request. Please try again.");
    } finally {
      setProcessingRequest(false);
    }
  };
  
  if (loading) {
    return <div>Loading debrief data...</div>;
  }
  
  return (
    <div className="campaign-debrief">
      <h2>Campaign Debrief</h2>
      
      {reportData && (
        <div className="report-summary">
          <h3>Current Status</h3>
          <p><strong>Character:</strong> {reportData.character.name}, Level {reportData.character.level} {reportData.character.class}</p>
          <p><strong>Current Objective:</strong> {reportData.campaign.current_objective}</p>
          
          {reportData.campaign.related_npcs.length > 0 && (
            <div>
              <p><strong>Related NPCs:</strong></p>
              <ul>
                {reportData.campaign.related_npcs.map((npc, index) => (
                  <li key={index}>{npc}</li>
                ))}
              </ul>
            </div>
          )}
          
          {reportData.campaign.related_locations.length > 0 && (
            <div>
              <p><strong>Known Locations:</strong></p>
              <ul>
                {reportData.campaign.related_locations.map((loc, index) => (
                  <li key={index}>{loc}</li>
                ))}
              </ul>
            </div>
          )}
        </div>
      )}
      
      <div className="input-section">
        <h3>What do you want to do next?</h3>
        <textarea
          value={userInput}
          onChange={(e) => setUserInput(e.target.value)}
          placeholder="Describe your actions or ask a question..."
          rows={5}
          className="debrief-input"
        />
        <button 
          onClick={handleSubmit} 
          disabled={processingRequest}
          className="btn-submit"
        >
          {processingRequest ? 'Processing...' : 'Submit'}
        </button>
      </div>
      
      {aiResponse && (
        <div className="ai-response">
          <h3>Response</h3>
          <div className="response-content">
            {aiResponse}
          </div>
        </div>
      )}
    </div>
  );
};

export default CampaignDebrief;